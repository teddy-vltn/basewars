BaseWars = BaseWars or {}
BaseWars.SpawnMenu = BaseWars.SpawnMenu or {}
BaseWars.SpawnMenu.FlattenedShop = BaseWars.SpawnMenu.FlattenedShop or {}

-- This function computes a hash value for a given input string using a basic algorithm.
-- The hash is generated by iterating over each character in the string, updating the hash value.
local function stringHash(input)
    local hash = 0
    local len = #input

    -- Iterate over each character in the input string
    for i = 1, len do
        local char = string.byte(input, i)
        
        -- Update the hash using a simple formula and ensure it remains within 32-bit boundaries
        hash = (hash * 31 + char) % 0xFFFFFFFF
    end

    return hash
end

-- This function generates a deterministic UUID for an item based on its properties.
-- The generated UUID is seeded by a hash of the item's properties, ensuring the UUID remains consistent for the same item.
function BaseWars.SpawnMenu.GenerateUUID(item)
    -- Convert the item properties into a single concatenated string
    local itemStr = item.Name .. item.Price .. item.Model .. item.ClassName

    -- Compute a hash from the concatenated string to seed the UUID generation
    local seed = stringHash(itemStr)
    
    -- A simple seeded pseudo-random number generator
    local function seededRandom()
        -- Update the seed using a basic linear congruential generator formula
        seed = (seed * 1103515245 + 12345) % 0x10000
        -- Normalize the seed value to a range of [0, 1)
        return (bit.band(seed, 0x7FFF)) / 0x7FFF
    end

    -- Using the seeded random function, replace 'x' and 'y' characters in the UUID template to generate the UUID
    local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
    return string.gsub(template, '[xy]', function (c)
        local r = seededRandom()
        if c == 'x' then
            return string.format('%x', math.floor(r * 16))
        else
            return string.format('%x', 8 + math.floor(r * 4))
        end
    end)
end

-- This function processes a shop's category table, assigning UUIDs to items.
-- It recursively traverses categories and subcategories, ensuring each item is given a unique identifier.
function BaseWars.SpawnMenu.AddUUIDsToShop(categoryTable)
    local newTable = {}

    -- Iterate over each entry in the category table
    for key, value in pairs(categoryTable) do
        -- Check if the value represents an item (by the presence of a ClassName)
        if value.ClassName then
            local UUID = BaseWars.SpawnMenu.GenerateUUID(value)
            print("Adding UUID " .. UUID .. " to " .. value.ClassName)
            newTable[UUID] = value
        -- If the value is a table but doesn't represent an item, treat it as a category or subcategory
        elseif type(value) == "table" and not value.ClassName then
            newTable[key] = BaseWars.SpawnMenu.AddUUIDsToShop(value)  -- Recursively process the subcategory
        else
            -- Any other type of value is directly copied to the new table
            newTable[key] = value
        end
    end
    
    return newTable
end

BaseWars.Config.Shop = BaseWars.SpawnMenu.AddUUIDsToShop(BaseWars.Config.Shop)

-- This function collects items from a category table up to a specified depth.
-- It's used to extract items from nested categories, creating a flattened view.
function BaseWars.SpawnMenu.CollectItems(categoryTable, depth)
    -- If the depth limit is reached, stop the recursion
    if depth <= 0 then return {} end

    local items = {}

    -- Iterate over each entry in the category table
    for key, categoryOrItem in pairs(categoryTable) do
        if type(categoryOrItem) ~= "table" then continue end
        
        -- If the entry has a Price, treat it as an item
        if categoryOrItem.Price then
            items[key] = categoryOrItem
        else
            -- Otherwise, treat it as a subcategory and recursively collect items from it
            local subItems = BaseWars.SpawnMenu.CollectItems(categoryOrItem, depth - 1)
            for subKey, item in pairs(subItems) do
                items[subKey] = item
            end
        end
    end

    return items
end

-- This function uses the CollectItems function to flatten the shop's structure.
-- The result is a single table containing all items, regardless of their nesting within categories.
function BaseWars.FlattenShop()
    -- Using an arbitrary depth of 10 ensures all items are collected, even from deeply nested categories
    local items = BaseWars.SpawnMenu.CollectItems(BaseWars.Config.Shop, 10)
    BaseWars.SpawnMenu.FlattenedShop = items
end

BaseWars.FlattenShop()

function BaseWars.SpawnMenu.GetWeaponAutoBuy(ply)
    return ply:GetNWBool("BaseWars_AutoBuy"), ply:GetNWString("BaseWars_AutoBuyWeapon")
end

local Player = FindMetaTable("Player")

function Player:GetBuyEntityBlockReason(uuid)
    local entityTable = BaseWars.SpawnMenu.FlattenedShop[uuid]
    if not entityTable then return "Entity does not exist" end

    local vip = entityTable.VIP
    if vip and not self:IsVIP() then return "VIP only", BaseWars.Color("YELLOW") end

    local level = entityTable.Level
    if level and level > self:GetLevel() then return "Level: " .. level, BaseWars.Color("RED") end

    return false
end

function Player:IsVIP()
    return false
end